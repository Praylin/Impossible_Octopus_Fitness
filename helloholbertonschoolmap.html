<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="initial-scale=1.0, width=device-width" />
  <link rel="stylesheet" type="text/css"
    href="https://js.api.here.com/v3/3.0/mapsjs-ui.css" />
  <script type="text/javascript" charset="UTF-8"
    src="https://js.api.here.com/v3/3.0/mapsjs-core.js"></script>
  <script type="text/javascript" charset="UTF-8"
    src="https://js.api.here.com/v3/3.0/mapsjs-service.js"></script>
  <script type="text/javascript" charset="UTF-8"
    src="https://js.api.here.com/v3/3.0/mapsjs-ui.js"></script>
  <script type="text/javascript" charset="UTF-8"
    src="https://js.api.here.com/v3/3.0/mapsjs-mapevents.js"></script>
</head>
<body>
  <div id="map" style="width: 100%; height: 100vh;">
  </div>
  <script  type="text/javascript" charset="UTF-8" >

/**
 * Boilerplate map initialization code starts below:
 */

//Step 1: initialize communication with the platform
var platform = new H.service.Platform({
  app_id: 'rQkB1H1oeYhYxcRY7LVM',
  app_code: '4KHKww7ENyjDb5XItlYbMw',
  useCIT: true,
  useHTTPS: true
});
var defaultLayers = platform.createDefaultLayers();

//Step 2: initialize a map - not specificing a location will give a whole world
// view.
var map = new H.Map(document.getElementById('map'),
  defaultLayers.normal.map);

//Step 3: make the map interactive
// MapEvents enables the event system
// Behavior implements default interactions for pan/zoom (also on mobile touch environments)
var behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));
// var rt = H.ui.ZoomRectangle(opt_options);

// Create the default UI components
var ui = H.ui.UI.createDefault(map, defaultLayers);
ui.addControl('zoomRectangle', new H.ui.ZoomRectangle());
var zoomRectangle = ui.getControl('zoomRectangle')
var mapSettings = ui.getControl('mapsettings');
var zoom = ui.getControl('zoom');
var scalebar = ui.getControl('scalebar');
zoomRectangle.setAlignment('right-middle');

// Add window resize listener to adjust the map dimensions.
window.addEventListener('resize', function () {
    map.getViewPort().resize();
});

//Moves the map to display over Holberton @param  {H.Map} map
//      A HERE Map instance within the application
  moveMapToHolberton(map);
  function moveMapToHolberton(map){
    map.setCenter({lat:37.7920934, lng:-122.3999152});
    map.setZoom(16);
  }

// Add 'Zoom in' context menu item and display 'Hello Holb...'
map.addEventListener('contextmenu',onContextMenuRequested);


function onContextMenuRequested(e) {
  e.items.push(new H.util.ContextItem({
  label: 'Hello Holberton School!',

  callback: john

  // ;function() {
  //   map.setZoom(map.getZoom() + 1);
  // }

  })

  );
};

  // map.addEventListener('tap',

  function john(evt) {
    var coord = map.screenToGeo(evt.currentPointer.viewportX,
      evt.currentPointer.viewportY);
    console.log('Clicked at ' + Math.abs(coord.lat.toFixed(4)) +
      ((coord.lat > 0) ? 'N' : 'S') +
      ' ' + Math.abs(coord.lng.toFixed(4)) +
      ((coord.lng > 0) ? 'E' : 'W'));
  }
// );



// Add map context menu event listener.
// map.addEventListener('contextmenu', onContextMenuRequested);
// .
// .
// .
// function onContextMenuRequested(e) {
//   // TO DO: add the context menu item to get the result as shown below.
// }


// Add event listeners:
// map.addEventListener('tap', function(evt) {
//   alert('Clicked at ' + evt.currentPointer.viewportX + ',' +
//   evt.currentPointer.viewportY);
// });

// Create the parameters for the reverse geocoding request:
var rgcParams = {
    prox: 'Math.abs(coord.lat.toFixed(4),Math.abs(coord.lng.toFixed(4)',
    mode: 'retrieveAddresses',
    maxresults: 1
  };

// Send the RGC request over.
// gc.reverseGeocode(rgcParams, function(result) {
//   onRGCResult(result, contextMenuEvent);
// }, function(error) {
//   console.log(error);
//   console.log(result);
// });


//
//   var bubble = new H.ui.InfoBubble({ lng: Math.abs(coord.lat.toFixed(4), lat: Math.abs(coord.lng.toFixed(4) }, {
//           content: '<b>Hello World!</b>'
//          });

  // Add info bubble to the UI:
  // ui.addBubble(bubble);

  // Define a callback function to process the response:
  // function onSuccess( result) {
  //   var location = result.Response.View[0].Result[0];

    // Create an InfoBubble at the returned location with
    // the address as its contents:
  //   ui.addBubble(new H.ui.InfoBubble({
  //     lat: location.Location.DisplayPosition.Latitude,
  //     lng: location.Location.DisplayPosition.Longitude
  //    }, { content: location.Location.Address.Label }));
  // };

// Get an instance of the geocoding service:
  // var geocoder = platform.getGeocodingService();

  // Call the geocode method with the geocoding parameters,
  // the callback and an error callback function (called if a
  // communication error occurs):
  // geocoder.reverseGeocode(
  //   reverseGeocodingParameters,
  //   onSuccess,
  //   function(e) { alert(e); });


// // Send the RGC request over.
// gc.reverseGeocode(rgcParams, function(result) {
//   onRGCResult(result, contextMenuEvent);
// }, function(error) {
//   console.log(error);
// });


/**
 * Processes reverse geocoder response and
 * adds a context menu item showing the associated address.
 */
// function onRGCResult(result, contextMenuEvent) {
//   var addressLabel = result.Response.View[0].Result[0]; // TODO: find the response JSON path to
// //get the address label.
//   contextMenuEvent.items.push(addressLabel); // TODO: add the address label as a context
// //menu item.
//   // Dispatch the context menu event again for all attached listeners to act with
// //new added item(s).
//   contextMenuEvent.currentTarget.dispatchEvent(contextMenuEvent);
// }
//

  </script>
</body>
</html>
